diff --git a/kernel/defs.h b/kernel/defs.h
index 4b9bbc0..140c14f 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -61,7 +61,9 @@ void            ramdiskrw(struct buf*);
 
 // kalloc.c
 void*           kalloc(void);
+void*           kalloc_noref(void);
 void            kfree(void *);
+void            kfree_init(void *);
 void            kinit(void);
 
 // log.c
@@ -168,9 +170,19 @@ void            uvmfree(pagetable_t, uint64);
 void            uvmunmap(pagetable_t, uint64, uint64, int);
 void            uvmclear(pagetable_t, uint64);
 uint64          walkaddr(pagetable_t, uint64);
+pte_t*          walk(pagetable_t, uint64, int);
 int             copyout(pagetable_t, uint64, char *, uint64);
 int             copyin(pagetable_t, char *, uint64, uint64);
 int             copyinstr(pagetable_t, char *, uint64, uint64);
+void            page_ref_inc(uint64);
+void            page_ref_zero(uint64);
+void            page_ref_dec(uint64);
+void            page_ref_lock(void);
+void            page_ref_unlock(void);
+int             page_ref_getcnt(uint64);
+void            page_ref_inc_wl(uint64);
+void            page_ref_dec_wl(uint64);
+int             cow_handler(uint64);
 
 // plic.c
 void            plicinit(void);
diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index fa6a0ac..1e5efa7 100644
--- a/kernel/kalloc.c
+++ b/kernel/kalloc.c
@@ -23,9 +23,53 @@ struct {
   struct run *freelist;
 } kmem;
 
+struct {
+  struct spinlock lock;
+  int ref[(PHYSTOP - KERNBASE) / PGSIZE];
+} page_ref;
+
+#define PA2IDX(pa) (((uint64)pa - KERNBASE) / PGSIZE)
+void page_ref_inc(uint64 pa){
+  acquire(&page_ref.lock);
+  ++page_ref.ref[PA2IDX(pa)];
+  release(&page_ref.lock);
+}
+void page_ref_one(uint64 pa){
+  acquire(&page_ref.lock);
+  page_ref.ref[PA2IDX(pa)] = 1;
+  release(&page_ref.lock);
+}
+void page_ref_dec(uint64 pa){
+  acquire(&page_ref.lock);
+  --page_ref.ref[PA2IDX(pa)];
+  release(&page_ref.lock);
+}
+
+void page_ref_lock(){
+  acquire(&page_ref.lock);
+}
+void page_ref_unlock(){
+  release(&page_ref.lock);
+}
+int page_ref_getcnt(uint64 pa){
+  return page_ref.ref[PA2IDX(pa)];
+}
+void page_ref_inc_wl(uint64 pa){
+  ++page_ref.ref[PA2IDX(pa)];
+}
+void page_ref_dec_wl(uint64 pa){
+  --page_ref.ref[PA2IDX(pa)];
+}
+
 void
 kinit()
 {
+  // debug 1: not initialize
+  initlock(&page_ref.lock, "page_ref");
+  acquire(&page_ref.lock);
+  memset(page_ref.ref, 0, sizeof(page_ref.ref));
+  release(&page_ref.lock);
+
   initlock(&kmem.lock, "kmem");
   freerange(end, (void*)PHYSTOP);
 }
@@ -36,7 +80,7 @@ freerange(void *pa_start, void *pa_end)
   char *p;
   p = (char*)PGROUNDUP((uint64)pa_start);
   for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
-    kfree(p);
+    kfree_init(p);
 }
 
 // Free the page of physical memory pointed at by v,
@@ -48,6 +92,34 @@ kfree(void *pa)
 {
   struct run *r;
 
+  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
+    panic("kfree");
+  
+  acquire(&page_ref.lock);
+  int idx = PA2IDX(pa);
+  if(--page_ref.ref[idx] > 0){
+    release(&page_ref.lock);
+    return;
+  }
+  page_ref.ref[idx] = 0; // when kinit, the value will be -1
+  release(&page_ref.lock);
+
+  // Fill with junk to catch dangling refs.
+  memset(pa, 1, PGSIZE);
+
+  r = (struct run*)pa;
+
+  acquire(&kmem.lock);
+  r->next = kmem.freelist;
+  kmem.freelist = r;
+  release(&kmem.lock);
+}
+
+void
+kfree_init(void *pa)
+{
+  struct run *r;
+
   if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
     panic("kfree");
 
@@ -76,6 +148,28 @@ kalloc(void)
     kmem.freelist = r->next;
   release(&kmem.lock);
 
+  if(r){
+    acquire(&page_ref.lock);
+    page_ref.ref[PA2IDX(r)] = 1;
+    release(&page_ref.lock);
+  }
+
+  if(r)
+    memset((char*)r, 5, PGSIZE); // fill with junk
+  return (void*)r;
+}
+
+void *
+kalloc_noref(void)
+{
+  struct run *r;
+
+  acquire(&kmem.lock);
+  r = kmem.freelist;
+  if(r)
+    kmem.freelist = r->next;
+  release(&kmem.lock);
+
   if(r)
     memset((char*)r, 5, PGSIZE); // fill with junk
   return (void*)r;
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 0aec003..466e42c 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -331,6 +331,7 @@ sfence_vma()
 #define PTE_W (1L << 2)
 #define PTE_X (1L << 3)
 #define PTE_U (1L << 4) // 1 -> user can access
+#define PTE_COW (1L << 8) // cow bit
 
 // shift a physical address to the right place for a PTE.
 #define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
diff --git a/kernel/trap.c b/kernel/trap.c
index a63249e..8286756 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -49,8 +49,10 @@ usertrap(void)
   
   // save user program counter.
   p->trapframe->epc = r_sepc();
+
+  uint64 scause = r_scause();
   
-  if(r_scause() == 8){
+  if(scause == 8){
     // system call
 
     if(p->killed)
@@ -67,6 +69,14 @@ usertrap(void)
     syscall();
   } else if((which_dev = devintr()) != 0){
     // ok
+  } else if(scause == 15){
+    uint64 va = r_stval();
+    if(va >= MAXVA){
+      exit(-1);
+    }
+    if(cow_handler(va) != 0){
+      exit(-1);
+    }
   } else {
     printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
     printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
diff --git a/kernel/vm.c b/kernel/vm.c
index bccb405..50caaa0 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -5,6 +5,8 @@
 #include "riscv.h"
 #include "defs.h"
 #include "fs.h"
+#include "spinlock.h"
+#include "proc.h"
 
 /*
  * the kernel's page table.
@@ -158,6 +160,7 @@ mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
       return -1;
     if(*pte & PTE_V)
       panic("remap");
+      
     *pte = PA2PTE(pa) | perm | PTE_V;
     if(a == last)
       break;
@@ -311,7 +314,7 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
   pte_t *pte;
   uint64 pa, i;
   uint flags;
-  char *mem;
+  // char *mem;
 
   for(i = 0; i < sz; i += PGSIZE){
     if((pte = walk(old, i, 0)) == 0)
@@ -319,14 +322,22 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
     if((*pte & PTE_V) == 0)
       panic("uvmcopy: page not present");
     pa = PTE2PA(*pte);
-    flags = PTE_FLAGS(*pte);
-    if((mem = kalloc()) == 0)
-      goto err;
-    memmove(mem, (char*)pa, PGSIZE);
-    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
-      kfree(mem);
+    flags = (PTE_FLAGS(*pte) & (~PTE_W)) | PTE_COW;
+    *pte = ((*pte) & (~PTE_W)) | PTE_COW;
+    
+    // if((mem = kalloc()) == 0)
+    //   goto err;
+    // memmove(mem, (char*)pa, PGSIZE);
+    // if(mappages(new, i, PGSIZE, (uint64)pa, flags) != 0){
+    //   kfree(mem);
+    //   goto err;
+    // }
+    if((pte = walk(new, i, 1)) == 0){
       goto err;
     }
+    *pte = PA2PTE(pa)| flags| PTE_V;
+    // increment the count of the page
+    page_ref_inc(pa);     
   }
   return 0;
 
@@ -358,6 +369,23 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
 
   while(len > 0){
     va0 = PGROUNDDOWN(dstva);
+    if(va0 >= MAXVA){
+      return -1;
+    }
+    
+    pte_t* pte = walk(pagetable, va0, 0);
+    if(pte == 0){
+      return -1;
+    }
+    if(((*pte) & PTE_V) == 0){
+      return -1;
+    }
+    if(((*pte) & PTE_COW) && !(*pte & PTE_W)){
+      // cow
+      if(cow_handler(va0) != 0){
+        return -1;
+      }
+    }
     pa0 = walkaddr(pagetable, va0);
     if(pa0 == 0)
       return -1;
@@ -440,3 +468,55 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
     return -1;
   }
 }
+
+int cow_handler(uint64 va){
+  struct proc* p = myproc();
+  va = PGROUNDDOWN(va);
+  pte_t* pte = walk(p->pagetable, va, 0);
+
+  if(pte == 0){
+    return -1;
+  }
+  if((*pte & PTE_COW) == 0){
+    return -1;
+  }
+    
+  uint64 pa = PTE2PA(*pte);
+  int flags = PTE_FLAGS(*pte);
+
+  flags = (flags & (~PTE_COW)) | PTE_W;
+
+  page_ref_lock(); // lock
+  int cnt = page_ref_getcnt(pa);
+  if(cnt == 1){
+    *pte = (*pte | PTE_W) & (~PTE_COW);
+    page_ref_unlock();
+  }
+  else{
+    // what if mem == 0 ?
+    // page_ref_dec_wl(pa);
+    // page_ref_unlock();
+
+    char* mem;
+    if((mem = kalloc_noref()) == 0){ // kalloc will increment the cnt
+      page_ref_unlock();
+      return -1;
+    }
+    memmove(mem, (char*)pa, PGSIZE); // forget it =-=
+    page_ref_dec_wl(pa);
+    page_ref_inc_wl((uint64)mem);
+    page_ref_unlock();
+    // *pte = PA2PTE(mem) | flags| PTE_V;   
+    // if(mappages(p->pagetable, va, PGSIZE, (uint64)mem, flags) != 0){
+    //   kfree(mem);
+    //   return -1;
+    // }
+    if((pte = walk(p->pagetable, va, 1)) == 0){
+      kfree(mem);
+      return -1;
+    }
+    *pte = PA2PTE(mem)| flags| PTE_V;
+  }
+
+  return 0;
+}
diff --git a/time.txt b/time.txt
new file mode 100644
index 0000000..7813681
--- /dev/null
+++ b/time.txt
@@ -0,0 +1 @@
+5
\ No newline at end of file
