diff --git a/Makefile b/Makefile
index 0fbaf7c..f3e461c 100644
--- a/Makefile
+++ b/Makefile
@@ -149,6 +149,11 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_sleep\
+	$U/_pingpong\
+	$U/_primes\
+	$U/_find\
+	$U/_xargs\
 
 
 ifeq ($(LAB),syscall)
diff --git a/gradelib.pyc b/gradelib.pyc
new file mode 100644
index 0000000..c3f6ede
Binary files /dev/null and b/gradelib.pyc differ
diff --git a/kernel/param.h b/kernel/param.h
index b5fdcb2..abc9955 100644
--- a/kernel/param.h
+++ b/kernel/param.h
@@ -6,6 +6,7 @@
 #define NDEV         10  // maximum major device number
 #define ROOTDEV       1  // device number of file system root disk
 #define MAXARG       32  // max exec arguments
+#define MAXARGLEN    512 // max argument length
 #define MAXOPBLOCKS  10  // max # of blocks any FS op writes
 #define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
diff --git a/time.txt b/time.txt
new file mode 100644
index 0000000..09f4f7c
--- /dev/null
+++ b/time.txt
@@ -0,0 +1 @@
+114514
\ No newline at end of file
diff --git a/user/find.c b/user/find.c
new file mode 100644
index 0000000..7141aa4
--- /dev/null
+++ b/user/find.c
@@ -0,0 +1,74 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+
+char target[512];
+
+void find_target(char* path){
+      // printf("path: %s\n", path);
+      char buf[512], *p;
+      int fd;
+      struct dirent de;
+      struct stat st;
+
+      if((fd = open(path, 0)) < 0){
+            fprintf(2, "find: cannot open %s\n", path);
+            return;
+      }
+
+      if(fstat(fd, &st) < 0){
+            fprintf(2, "find: cannot stat %s\n", path);
+            close(fd);
+            return;
+      }
+      
+      // printf("here.\n");
+      if(st.type == T_DIR){
+            if(strlen(path) + 1 + DIRSIZ + 1 > 512){
+                  printf("find: path too long\n");
+                  goto end;
+            }
+            strcpy(buf, path);
+            p = buf + strlen(path);
+            *p++ = '/';
+            while(read(fd, &de, sizeof(de)) > 0){
+                  if(de.inum == 0){
+                        continue;
+                  }
+                  // ignore . and ..
+                  if(de.name[0] == '.'){
+                        if(de.name[1] == 0 || (de.name[1] == '.' && de.name[2] == 0)){
+                              continue;
+                        }
+                  }
+                  // printf("de.name: %s\n", de.name);
+                  memmove(p, de.name, DIRSIZ);
+                  p[DIRSIZ] = 0;
+                  if(stat(buf, &st) < 0){ // it is buf not path
+                        fprintf(2, "find: cannot stat");
+                  }
+                  if(st.type == T_FILE && strcmp(de.name, target) == 0){
+                        printf("%s\n", buf); // buf plz
+                  }
+                  else if(st.type == T_DIR){
+                        find_target(buf);  // buf plz
+                  }
+            }
+      }
+
+      end:
+
+      close(fd);
+      return;
+}
+
+int main(int argc, char* argv[]){
+      if(argc != 3){
+            fprintf(2, "arguments error");
+            exit(1);
+      }
+      strcpy(target, argv[2]);
+      find_target(argv[1]);
+      exit(0);
+}
\ No newline at end of file
diff --git a/user/pingpong.c b/user/pingpong.c
new file mode 100644
index 0000000..2d249dc
--- /dev/null
+++ b/user/pingpong.c
@@ -0,0 +1,38 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int main(int argc, char* argv[]){
+      int p1[2], p2[2];
+      if(pipe(p1) < 0){
+            printf("pipe: error.");
+            exit(1);
+      }
+      if(pipe(p2) < 0){
+            printf("pipe: error.");
+            exit(1);
+      }
+
+      char byte = 'x';
+
+      if(fork() == 0){
+            // child proc
+            if(read(p1[0], &byte, 1) > 0){
+                  printf("%d: received ping\n", getpid());
+                  write(p2[1], &byte, 1);
+            }
+      }
+      else{
+            write(p1[1], &byte, 1);
+            if(read(p2[0], &byte, 1) > 0){
+                  printf("%d: received pong\n", getpid());
+            }
+      }
+
+      close(p1[0]);
+      close(p1[1]);
+      close(p2[0]);
+      close(p2[1]);
+
+      exit(0);
+}
\ No newline at end of file
diff --git a/user/primes.c b/user/primes.c
new file mode 100644
index 0000000..6b558e8
--- /dev/null
+++ b/user/primes.c
@@ -0,0 +1,69 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+
+void primes_pipe(int rd){
+      int n, x;
+
+      if(read(rd, &n, 4) == 0){
+            close(rd);
+            return;
+      }
+
+      printf("prime %d\n", n);
+      int p[2];
+      if(pipe(p) < 0){
+            printf("pipe: error");
+            exit(1);
+      }
+      
+      if(fork() == 0){
+            close(rd);
+            close(p[1]);
+            primes_pipe(p[0]);
+            exit(0);
+
+      }
+      else{
+            close(p[0]);
+            while(read(rd, &x, 4) > 0){
+                  if(x%n){
+                        write(p[1], &x, 4);
+                  }
+            }
+            close(rd);
+            close(p[1]);
+            wait(0);
+      }
+      exit(0);
+}
+
+
+
+int main(int argc, char* argv[]){
+      int p[2];
+      if(pipe(p) < 0){
+            printf("pipe: error");
+            exit(1);
+      }
+
+      if(fork() == 0){
+            close(p[1]);
+            primes_pipe(p[0]);
+      }
+      else{
+            printf("prime 2\n");
+            close(p[0]);
+            for(int i = 3; i <= 35; ++i){
+                  if(i%2){
+                        // 4 bytes
+                        write(p[1], &i, 4);
+                  }
+            }
+            close(p[1]);
+            // it will end when child proc returns
+            wait(0);
+      }
+      exit(0);
+}
\ No newline at end of file
diff --git a/user/sleep.c b/user/sleep.c
new file mode 100644
index 0000000..19875ae
--- /dev/null
+++ b/user/sleep.c
@@ -0,0 +1,13 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int main(int argc, char* argv[]){
+      if(argc < 2){
+            printf("sleep: lack of arguments.\n");
+            exit(1);
+      }
+
+      sleep(atoi(argv[1]));
+      exit(0);
+}
\ No newline at end of file
diff --git a/user/xargs.c b/user/xargs.c
new file mode 100644
index 0000000..6cbf2cd
--- /dev/null
+++ b/user/xargs.c
@@ -0,0 +1,49 @@
+#include "kernel/types.h"
+#include "kernel/param.h"
+#include "user/user.h"
+
+
+int main(int argc, char* argv[]){
+      if(argc <= 1){
+            printf("xargs: arguments too few.");
+            exit(1);
+      }
+
+      char** argv_ = malloc(MAXARG); // defined in kernel/param.h
+      char* buf = malloc(MAXARGLEN);
+      int i = 1;
+
+      for(; i < argc; ++i){
+            argv_[i-1] = argv[i];
+      }
+      argv_[i] = 0;
+      --i;
+      
+      int n, j;
+      while(1){
+            j = 0;
+
+            while((n = read(0, &buf[j], 1)) > 0){
+                  if(buf[j] == '\n'){
+                        // one argument's end
+                        break;
+                  }
+                  ++j;
+            }
+
+            if(!n){
+                  break;
+            }
+
+            buf[j] = 0;
+            argv_[i] = buf;
+
+            if(fork() == 0){
+                  exec(argv[1], argv_);
+            }
+            else{
+                  wait(0);
+            }
+      }
+      exit(0);
+}
\ No newline at end of file
